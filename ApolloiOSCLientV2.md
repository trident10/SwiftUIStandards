# GraphQL Integration with Apollo iOS

## Overview

This implementation provides a clean, protocol-based approach to integrate Apollo GraphQL into your existing REST-based networking layer using modern Swift concurrency.

## Implementation

### Protocols

```swift
import Foundation
import Apollo

// MARK: - Protocols

/// Protocol defining the error type requirements for GraphQL operations
protocol ErrorType: Error {
    init(message: String)
    init(from error: Error)
}

/// Protocol defining the configuration for GraphQL queries
protocol GraphQLConfig {
    associatedtype Query: GraphQLQuery
    associatedtype Error: ErrorType
    
    var url: URL { get }
    var query: Query { get }
}
```

### Repository Extension

```swift
// MARK: - Repository Extension

extension Repository {
    /// Performs a GraphQL query using Apollo client
    /// - Parameter config: The GraphQL configuration containing URL, query, and error type
    /// - Returns: A Result containing either the query data or an error
    func performGraphQLQuery<Config: GraphQLConfig>(
        _ config: Config
    ) async -> Result<Config.Query.Data, Config.Error> {
        
        // Create Apollo client with the provided URL
        let store = ApolloStore(cache: InMemoryNormalizedCache())
        let provider = DefaultInterceptorProvider(store: store)
        let transport = RequestChainNetworkTransport(
            interceptorProvider: provider,
            endpointURL: config.url
        )
        let client = ApolloClient(networkTransport: transport, store: store)
        
        // Perform the query using Swift concurrency
        do {
            let result = try await withCheckedThrowingContinuation { continuation in
                client.fetch(query: config.query) { result in
                    continuation.resume(with: result)
                }
            }
            
            guard let data = result.data else {
                let error = Config.Error(message: "No data received from GraphQL query")
                return .failure(error)
            }
            
            return .success(data)
            
        } catch {
            let customError = Config.Error(from: error)
            return .failure(customError)
        }
    }
}
```

### Example Implementation

```swift
// MARK: - Example Implementation

// Example concrete error type
struct NetworkError: ErrorType {
    let message: String
    let underlyingError: Error?
    
    init(message: String) {
        self.message = message
        self.underlyingError = nil
    }
    
    init(from error: Error) {
        if let apolloError = error as? Apollo.GraphQLError {
            self.message = apolloError.message ?? "GraphQL Error"
        } else {
            self.message = error.localizedDescription
        }
        self.underlyingError = error
    }
}

// Example GraphQL query (you would generate this using Apollo iOS code generation)
struct UserQuery: GraphQLQuery {
    let id: String
    
    var queryDocument: String {
        """
        query GetUser($id: ID!) {
            user(id: $id) {
                id
                name
                email
            }
        }
        """
    }
    
    var variables: [String: Any]? {
        ["id": id]
    }
    
    // This would be generated by Apollo
    struct Data: GraphQLSelectionSet {
        let user: User?
        
        struct User: GraphQLSelectionSet {
            let id: String
            let name: String
            let email: String
        }
    }
}

// Example concrete GraphQL configuration
struct UserGraphQLConfig: GraphQLConfig {
    typealias Query = UserQuery
    typealias Error = NetworkError
    
    let url: URL
    let query: UserQuery
    
    init(baseURL: URL, userId: String) {
        self.url = baseURL.appendingPathComponent("/graphql")
        self.query = UserQuery(id: userId)
    }
}
```

### Usage Example

```swift
// MARK: - Usage Example

class ExampleUsage {
    let repository: Repository
    
    init(repository: Repository) {
        self.repository = repository
    }
    
    func fetchUser(userId: String) async {
        let config = UserGraphQLConfig(
            baseURL: URL(string: "https://api.example.com")!,
            userId: userId
        )
        
        let result = await repository.performGraphQLQuery(config)
        
        switch result {
        case .success(let data):
            if let user = data.user {
                print("User: \(user.name) - \(user.email)")
            } else {
                print("User not found")
            }
            
        case .failure(let error):
            print("Error fetching user: \(error.message)")
        }
    }
}
```

### Enhanced Implementation with Additional Options

```swift
// MARK: - Alternative Implementation with Caching and Headers

extension Repository {
    /// Enhanced version with additional configuration options
    func performGraphQLQuery<Config: GraphQLConfig>(
        _ config: Config,
        headers: [String: String] = [:],
        cachePolicy: CachePolicy = .fetchIgnoringCacheData
    ) async -> Result<Config.Query.Data, Config.Error> {
        
        // Create Apollo client with custom configuration
        let cache = InMemoryNormalizedCache()
        let store = ApolloStore(cache: cache)
        
        let provider = DefaultInterceptorProvider(store: store)
        let transport = RequestChainNetworkTransport(
            interceptorProvider: provider,
            endpointURL: config.url,
            additionalHeaders: headers
        )
        
        let client = ApolloClient(networkTransport: transport, store: store)
        
        do {
            let result = try await withCheckedThrowingContinuation { continuation in
                client.fetch(
                    query: config.query,
                    cachePolicy: cachePolicy
                ) { result in
                    continuation.resume(with: result)
                }
            }
            
            guard let data = result.data else {
                let error = Config.Error(message: "No data received from GraphQL query")
                return .failure(error)
            }
            
            return .success(data)
            
        } catch {
            let customError = Config.Error(from: error)
            return .failure(customError)
        }
    }
}
```

### Repository Protocol Reference

```swift
// MARK: - Repository Protocol (for reference)

protocol Repository {
    // Your existing REST methods would be here
    // func performRESTRequest(...) async throws -> ...
}

// Concrete implementation
class NetworkRepository: Repository {
    // Your existing REST implementation
    // Now also includes GraphQL support through the extension
}
```

## Key Features

### 1. Protocol-Based Design
- `GraphQLConfig` protocol with associated types for query and error
- `ErrorType` protocol for custom error handling
- Clean separation of concerns

### 2. Modern Swift Concurrency
- Uses `async`/`await` pattern
- Converts Apollo's callback-based API to Swift concurrency using `withCheckedThrowingContinuation`

### 3. Apollo Client Integration
- Creates a fresh Apollo client for each request (consider caching in production)
- Includes proper error handling and data validation

### 4. Type Safety
- Leverages Swift's type system with associated types
- Compile-time guarantees for query and error types

### 5. Flexibility
- Enhanced version supports custom headers for authentication
- Configurable cache policies
- Easy to extend with interceptors

## Usage Pattern

```swift
// 1. Create a concrete configuration
let config = UserGraphQLConfig(baseURL: baseURL, userId: "123")

// 2. Call the method
let result = await repository.performGraphQLQuery(config)

// 3. Handle the result
switch result {
case .success(let data):
    // Use the typed data
case .failure(let error):
    // Handle the typed error
}
```

## Production Considerations

### Apollo Code Generation
In production, use Apollo's code generation tools to automatically generate:
- GraphQL query types
- Response data models
- Type-safe variable handling

### Client Caching
Consider caching the Apollo client instance:
```swift
class NetworkRepository: Repository {
    private lazy var apolloClient: ApolloClient = {
        // Configure and return a shared client
    }()
}
```

### Error Handling
Extend error handling for specific GraphQL errors:
```swift
enum GraphQLErrorType {
    case networkError
    case graphQLErrors([GraphQLError])
    case parseError
    case unauthorized
}
```

### Authentication
Add authentication interceptors:
```swift
class AuthenticationInterceptor: ApolloInterceptor {
    func interceptAsync<Operation: GraphQLOperation>(
        chain: RequestChain,
        request: HTTPRequest<Operation>,
        response: HTTPResponse<Operation>?,
        completion: @escaping (Result<GraphQLResult<Operation.Data>, Error>) -> Void
    ) {
        request.addHeader(name: "Authorization", value: "Bearer \(token)")
        chain.proceedAsync(request: request, response: response, completion: completion)
    }
}
```

### Logging and Monitoring
Implement logging interceptors for debugging and monitoring:
```swift
class LoggingInterceptor: ApolloInterceptor {
    // Log requests and responses
}
```

## Dependencies

Add to your `Package.swift`:
```swift
dependencies: [
    .package(url: "https://github.com/apollographql/apollo-ios.git", from: "1.0.0")
]
```

Or using CocoaPods:
```ruby
pod 'Apollo', '~> 1.0'
```

## Summary

This implementation provides a robust foundation for integrating GraphQL into your existing iOS networking layer while maintaining:
- Type safety through protocols and associated types
- Modern Swift concurrency patterns
- Clean integration with existing REST infrastructure
- Flexibility for authentication, caching, and monitoring
- Clear separation between configuration and execution
